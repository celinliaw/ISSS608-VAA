{
  "hash": "f8c7ed89c2bc18134c3a3af782d4a096",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take-Home_Ex02\"\nauthor: \"Liaw Ying Ting, Celin\"\ndate: 27 May 2025\ndate-modified: \"last-modified\"\n\nformat: docx\n\nexecute: \n  eval: false\n  echo: true\n  warning: false\n  freeze: true\n---\n\n\n\n# Overview - Mini Challenge 3\n\nFor this take-home exercise 2, Mini-Challenge 3 will be chosen and the visualisation will be done on this topic. The background of the mini challenge and the questions will be listed below. For this mini challenge, I will only be displaying and addressing **Questions 2 and 3** below.\n\n# Background\n\nOver the past decade, the community of Oceanus has faced numerous transformations and challenges evolving from its fishing-centric origins. Following major crackdowns on illegal fishing activities, suspects have shifted investments into more regulated sectors such as the ocean tourism industry, resulting in growing tensions. This increased tourism has recently attracted the likes of international pop star Sailor Shift, who announced plans to film a music video on the island.\n\nClepper Jessen, a former analyst at FishEye and now a seasoned journalist for the Hacklee Herald, has been keenly observing these rising tensions. Recently, he turned his attention towards the temporary closure of Nemo Reef. By listening to radio communications and utilizing his investigative tools, Clepper uncovered a complex web of expedited approvals and secretive logistics. These efforts revealed a story involving high-level Oceanus officials, Sailor Shift’s team, local influential families, and local conservationist group The Green Guardians, pointing towards a story of corruption and manipulation.\n\n# Task and Question\n\nClepper diligently recorded all intercepted radio communications over the last two weeks. With the help of his intern, they have analyzed their content to identify important events and relationships between key players. The result is a knowledge graph describing the last two weeks on Oceanus. Clepper and his intern have spent a large amount of time generating this knowledge graph, and they would now like some assistance using it to answer the following questions.\n\n1.  **Clepper found that messages frequently came in at around the same time each day.**\n\n    -   Develop a graph-based visual analytics approach to identify any daily temporal patterns in communications.\n\n    -   How do these patterns shift over the two weeks of observations?\n\n    -   Focus on a specific entity and use this information to determine who has influence over them.\n\n2.  **Clepper has noticed that people often communicate with (or about) the same people or vessels, and that grouping them together may help with the investigation.**\n\n    -   Use visual analytics to help Clepper understand and explore the interactions and relationships between vessels and people in the knowledge graph.\n\n    -   Are there groups that are more closely associated? If so, what are the topic areas that are predominant for each group?\n\n        -   For example, these groupings could be related to: Environmentalism (known associates of Green Guardians), Sailor Shift, and fishing/leisure vessels.\n\n3.  **It was noted by Clepper’s intern that some people and vessels are using pseudonyms to communicate.**\n\n    -   Expanding upon your prior visual analytics, determine who is using pseudonyms to communicate, and what these pseudonyms are.\n\n        Some that Clepper has already identified include: “Boss”, and “The Lookout”, but there appear to be many more.\n\n        To complicate the matter, pseudonyms may be used by multiple people or vessels.\n\n    -   Describe how your visualizations make it easier for Clepper to identify common entities in the knowledge graph.\n\n    -   How does your understanding of activities change given your understanding of pseudonyms?\n\n4.  **Clepper suspects that Nadia Conti, who was formerly entangled in an illegal fishing scheme, may have continued illicit activity within Oceanus.**\n\n    -   Through visual analytics, provide evidence that Nadia is, or is not, doing something illegal.\n\n    -   Summarize Nadia’s actions visually. Are Clepper’s suspicions justified?\n\n**Reflection Questions**\n\n-   Given the task to develop visualizations for knowledge graphs, did you find that the challenge pushed you to develop new techniques for visual representation?\n\n-   Did you participate in last year’s challenge? If so, did your experience last year help prepare you for this year’s challenge?\n\n-   What was the most difficult part of working on this year’s data and what could have made it more accessible?\n\n# MC3 Kickstarter\n\n## Getting Started\n\nIn the code chunk below, `p_load()` of pacman package is used to load the R packages into R environment.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse, jsonlite,\n               tidygraph, ggraph,\n               SmartEDA, lubridate,\n               dplyr, igraph,\n               grid)\n```\n:::\n\n\n\n## Import knowledge Graph Data\n\nFor this exercise, *mc3.json* file will be used. In the code chunk below, `fromJSON()` of jsonlite package is used to import *mc3.json* file into R and save the output object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMC3 <- fromJSON(\"data/MC3_graph.json\")\nMC3_schema <- fromJSON(\"data/MC3_schema.json\")\n```\n:::\n\n\n\n## Inspecting Knowledge graph structure\n\nIn the code chunk below, `glimpse()` is used to reveal the structure of the *mc3* knowledge graph.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(MC3)\n```\n:::\n\n\n\n## Extracting the edges and nodes tables\n\nNext, `as_tibble()` of tibble package is used to extract the nodes and links tibble data frames from *mc3* tibble dataframe into two separate tibble dataframes called *mc3_nodes* and *mc3_edges* respectively.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_nodes <- as_tibble(MC3$nodes)\nmc3_edges <- as_tibble(MC3$edges)\n```\n:::\n\n\n\n## Initial EDA\n\nIn the code chunk below, `ExpCatViz()` of SmartEDA package is used to reveal the frequency distribution of all categorical fields in *mc3_nodes* tibble dataframe\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nExpCatViz(data=mc3_nodes,\n          col=\"lightblue\")\n```\n:::\n\n\n\nOn the other hand, code chunk below uses `ExpCATViz()` of SmartEDA package to reveal the frequency distribution of all categorical fields in *mc3_edges* tibble dataframe\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nExpCatViz(data=mc3_edges,\n          col=\"lightblue\")\n```\n:::\n\n\n\n## Data Cleaning and Wrangling\n\nThe code chunk below performs the following data cleaning tasks:\n\n-   convert values in id field into character data type\n\n-   exclude records with `id` value\n\n-   exclude records with similar id values\n\n-   exclude `thing_collected` field\n\n-   save the cleaned tibble dataframe into a new tibble datatable called `mc_nodes_cleaned`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_nodes_cleaned <- mc3_nodes %>%\n  mutate(id = as.character(id)) %>%\n  filter(!is.na(id)) %>%\n  distinct(id, .keep_all = TRUE) %>%\n  select(-thing_collected)\n```\n:::\n\n\n\n## Cleaning and wrangling edges\n\nNext, the code chunk will be used to:\n\n-   rename source and target fields to form_id and to_id respectively\n\n-   convert values in from_id and to_id fields to character data type\n\n-   exclude values in from_id and to_id which is not found in the id field of mc3_nodes_cleaned\n\n-   exclude records whereby from_id and/or to_id values are missing\n\n-   save the cleaned tibble dataframe and call it mc3_edges_cleaned\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_edges_cleaned <- mc3_edges %>%\n  rename(from_id = source,\n         to_id = target) %>%\n  mutate(across(c(from_id, to_id),\n                as.character)) %>%\n  filter(from_id %in% mc3_nodes_cleaned$id,\n         to_id %in% mc3_nodes_cleaned$id) %>%\n  filter(!is.na(from_id), !is.na(to_id))\n```\n:::\n\n\n\nNext, code chunk below will be used to create mapping of character id in `mc3_nodes_cleaned` to row index.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnode_index_lookup <- mc3_nodes_cleaned %>%\n  mutate(.row_id = row_number()) %>%\n  select(id, .row_id)\n```\n:::\n\n\n\nNext, the code chunk below will be used to join and convert `from_id` and `to_id` to integer indices. At the same time, we will drop rows with unmatched nodes.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_edges_indexed <- mc3_edges_cleaned %>%\n  left_join(node_index_lookup, \n            by = c(\"from_id\" = \"id\")) %>%\n  rename(from = .row_id) %>%\n  left_join(node_index_lookup, \n            by = c(\"to_id\" = \"id\")) %>%\n  rename(to = .row_id) %>%\n  select(from, to, is_inferred, type) %>%\n  filter(!is.na(from) & !is.na(to))  \n```\n:::\n\n\n\nNext, the code chunk below is used to subset nodes to only those referenced by edges\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nused_node_indices <- sort(\n  unique(c(mc3_edges_indexed$from, \n           mc3_edges_indexed$to)))\n\nmc3_nodes_final <- mc3_nodes_cleaned %>%\n  slice(used_node_indices) %>%\n  mutate(new_index = row_number())\n```\n:::\n\n\n\nWe will then use th code chunk below to rebuild lookup from old index to new index\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nold_to_new_index <- tibble(\n  old_index = used_node_indices,\n  new_index = seq_along(\n    used_node_indices))\n```\n:::\n\n\n\nLastly, the code chunk below will be used to update edge indices to match new node table\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_edges_final <- mc3_edges_indexed %>%\n  left_join(old_to_new_index, \n            by = c(\"from\" = \"old_index\")) %>%\n  rename(from_new = new_index) %>%\n  left_join(old_to_new_index, \n            by = c(\"to\" = \"old_index\")) %>%\n  rename(to_new = new_index) %>%\n  select(from = from_new, to = to_new, \n         is_inferred, type)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(mc3_edges_final)\n```\n:::\n\n\n\n# Building the tidygraph object\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc3_graph <- tbl_graph(\n  nodes = mc3_nodes_final,\n  edges = mc3_edges_final,\n  directed = TRUE\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(mc3_graph)\n```\n:::\n\n\n\n# Visualising the knowledge graph\n\nSeveral of the ggraph layouts involve randomisation. In order to ensure reproducibility, it is necessary to set the seed value before plotting by using the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n```\n:::\n\n\n\nIn the code chunk below, ggraph functions are used to create the whole graph\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(mc3_graph, \n       layout = \"fr\") +\n  geom_edge_link(alpha = 0.3, \n                 colour = \"gray\") +\n  geom_node_point(aes(color = `type`), \n                  size = 4) +\n  geom_node_text(aes(label = type), \n                 repel = TRUE, \n                 size = 1.0) +\n  theme_void()\n```\n:::\n\n\n\n# Question 2\n\n::: panel-tabset\n### Data Cleaning\n\nFor nodes, the code `filter()` will be used to filter out only *Person and Vessel* from *Entity*, and *Communication* from *Event* and their *relationship.*\n\nAfter this filter, the nodes only contain:\n\n-   entity nodes whose sub_type is Person or Vessel\n\n-   Event nodes whose sub_type is Communication\n\n-   Any node whose type is Relationship.\n\n`mutate()` adds a new column called idx to the filtered data frame\n\n`select()` extracts 2 columns from *selected_nodes* and give them a new id and rename to *id_map*\n\nFor Edges, `filter()` keeps only those where both endpoints are in the *old* column of *id_map.*\n\n`left_join()` matches each row's *to* value against *id_map\\$old* and brings in *id_map\\$new* for that *to* node and renames it *to_new*. Same thing for the *from* column.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselected_nodes <- mc3_nodes_final %>%\n  filter(\n    (type == \"Entity\"     & sub_type %in% c(\"Person\", \"Vessel\")) |\n    (type == \"Event\"      & sub_type == \"Communication\")      |\n    (type == \"Relationship\")\n  ) %>%\n  mutate(idx = row_number())\n\n# mapping old_index → new idx\nid_map <- selected_nodes %>%\n  select(old = new_index, new = idx)\n\n# 2. filter edges so both ends are in selected_nodes\nselected_edges <- mc3_edges_final %>%\n  filter(from %in% id_map$old, to %in% id_map$old) %>%\n  \n  # 3. re-index the endpoints\n  left_join(id_map, by = c(\"from\" = \"old\")) %>%\n  rename(from_new = new) %>%\n  left_join(id_map, by = c(\"to\"   = \"old\")) %>%\n  rename(to_new   = new) %>%\n  select(from = from_new, to = to_new, type)\n```\n:::\n\n\n\n### People/Vessel Vs Relationship Subtypes\n\nStep 1: we proceed to `filter()` only the edges that we want, specifically *sent, received and evidence_for*. The labels for the edges show \"sent\", \"received\" and \"evidence_for\" using `transmute()`.\n\nStep 2: We then build the node table and colour by sub_type which is called *group*. The label for the names/vessels will be placed under the node using *label.*\n\nStep 3: Draw a Visnetwork graph.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(tidyr)       # for pivot_longer()\nlibrary(visNetwork)\nlibrary(RColorBrewer)\n\n# 1. Build sender/receiver pairs and their relationship nodes\nsend_pairs <- mc3_edges_final %>%\n  filter(type == \"sent\") %>%\n  rename(sender = from, comm = to) %>%\n  select(sender, comm)\n\nrecv_pairs <- mc3_edges_final %>%\n  filter(type == \"received\") %>%\n  rename(receiver = to, comm = from) %>%\n  select(receiver, comm)\n\nrel_edges <- mc3_edges_final %>%\n  filter(type %in% c(\"evidence_for\", \"is_inferred\")) %>%\n  rename(rel = to, comm = from) %>%\n  select(rel, comm)\n\n# 2. Join to get each (sender, receiver, rel) for every communication event\ntriplets <- send_pairs %>%\n  inner_join(recv_pairs, by = \"comm\") %>%\n  inner_join(rel_edges, by = \"comm\") %>%\n  mutate(\n    person1 = pmin(sender, receiver),\n    person2 = pmax(sender, receiver)\n  ) %>%\n  distinct(person1, person2, rel, .keep_all = TRUE) %>%\n  select(person1, person2, rel)\n\n# 3. Collect unique node‐IDs used (persons/vessels and relationship nodes)\nnode_ids_used <- unique(c(triplets$person1, triplets$person2, triplets$rel))\n\n# 4. Build a lookup of node info for those IDs,\n#    but filter to only Person/Vessel entity subtypes and Relationship nodes\nnodes_sub <- mc3_nodes_final %>%\n  filter(new_index %in% node_ids_used) %>%\n  filter(\n    sub_type %in% c(\"Person\", \"Vessel\") |\n    type == \"Relationship\"\n  ) %>%\n  select(new_index, label, sub_type, type)\n\n# 4a. Define pleasing, non‐grey colors for entity subtypes\nentity_color_map <- tibble(\n  sub_type = c(\"Person\", \"Vessel\"),\n  color    = c(\"#2c7fb8\", \"#e6550d\")  # blue for Person, orange for Vessel\n)\n\n# 4b. Identify all relationship subtypes and assign distinct, visually pleasing colors\nrel_subtypes <- nodes_sub %>%\n  filter(type == \"Relationship\") %>%\n  distinct(sub_type) %>%\n  arrange(sub_type) %>%\n  pull(sub_type)\n\nn_rels <- length(rel_subtypes)\nif (n_rels > 0) {\n  base_palette <- brewer.pal(min(n_rels, 8), \"Set2\")\n  if (n_rels > length(base_palette)) {\n    rel_colors <- colorRampPalette(base_palette)(n_rels)\n  } else {\n    rel_colors <- base_palette[1:n_rels]\n  }\n  rel_color_map <- tibble(\n    sub_type = rel_subtypes,\n    color    = rel_colors\n  )\n} else {\n  rel_color_map <- tibble(sub_type = character(0), color = character(0))\n}\n\n# 4c. Combine entity and relationship color mappings\ncolor_map <- bind_rows(entity_color_map, rel_color_map)\n\n# 4d. Build nodes_vis with assigned colors (no grey)\nnodes_vis <- nodes_sub %>%\n  left_join(color_map, by = \"sub_type\") %>%\n  transmute(\n    id       = new_index,\n    label    = label,\n    sub_type = sub_type,\n    color    = color\n  )\n\n# 5. Build the visNetwork 'edges' data frame\n# 5a. Edges between the two people/vessels (no label)\nedges_comm_vis <- triplets %>%\n  transmute(\n    from   = person1,\n    to     = person2,\n    label  = \"\",     # no “comm” text\n    width  = 2,\n    arrows = \"to\"\n  )\n\n# 5b. For each triplet, connect both persons to the relationship node (no label)\nedges_rel_vis <- triplets %>%\n  pivot_longer(\n    cols      = c(person1, person2),\n    names_to  = NULL,\n    values_to = \"person\"\n  ) %>%\n  transmute(\n    from   = person,\n    to     = rel,\n    label  = \"\",    # no text here\n    width  = 1,\n    arrows = \"to\"\n  )\n\n# 5c. Combine both sets of edges\nedges_vis <- bind_rows(edges_comm_vis, edges_rel_vis)\n\n# 6. Draw the visNetwork with a dropdown filter by sub_type.\n#    Legend shows only subtypes in the graph, in oval shape, larger, and using our custom colors.\nvisNetwork(nodes_vis, edges_vis) %>%\n  visNodes(\n    borderWidth         = 1,\n    borderWidthSelected = 2\n  ) %>%\n  visEdges(\n    arrows = \"to\",\n    color  = list(color = \"#333333\", highlight = \"#FF0000\"),  # dark edge color\n    font   = list(align = \"middle\")\n  ) %>%\n  visOptions(\n    highlightNearest = TRUE,\n    nodesIdSelection = TRUE,\n    selectedBy       = \"sub_type\"\n  ) %>%\n  visLegend(\n    addNodes = data.frame(\n      label = color_map$sub_type,\n      shape = \"ellipse\", \n      color = color_map$color,\n      size  = rep(20, nrow(color_map))\n    ),\n    useGroups = FALSE\n  )\n```\n:::\n\n\n\n### People vs Relationship Subtype\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 7. Exclude all “Vessel” nodes and any edges involving them\nnodes_vis2 <- nodes_vis %>%\n  filter(sub_type != \"Vessel\")\n\nedges_vis2 <- edges_vis %>%\n  filter(from %in% nodes_vis2$id, to %in% nodes_vis2$id)\n\n# 8. Build a reduced legend data.frame for the remaining subtypes\nlegend_map2 <- color_map %>%\n  filter(sub_type %in% unique(nodes_vis2$sub_type))\n\n# 9. Draw the new visNetwork without Vessel nodes\nvisNetwork(nodes_vis2, edges_vis2) %>%\n  visNodes(\n    borderWidth         = 1,\n    borderWidthSelected = 2\n  ) %>%\n  visEdges(\n    arrows = \"to\",\n    color  = list(color = \"#333333\", highlight = \"#FF0000\"),\n    font   = list(align = \"middle\")\n  ) %>%\n  visOptions(\n    highlightNearest = TRUE,\n    nodesIdSelection = TRUE,\n    selectedBy       = \"sub_type\"\n  ) %>%\n  visLegend(\n    addNodes = data.frame(\n      label = legend_map2$sub_type,\n      shape = \"ellipse\",\n      color = legend_map2$color,\n      size  = rep(20, nrow(legend_map2))\n    ),\n    useGroups = FALSE\n  )\n```\n:::\n\n\n:::\n\n### Q2 Part A\n\nBy selecting the different sub-groups from the drop-down below, we can conclude the following information.\n\n**Colleagues:**\n\n-   Boss, Mrs Money and The Middleman\n\n-   Boss, The Accountant and The Middleman\n\n-   The Lookout, The Intern and Mrs Money\n\n-   Mrs Money and The Intern\n\n-   Boss and Mrs Money\n\n-   Boss and Rodriguez\n\n-   Small Fry and Davis\n\n-   Nadia Conti and Davis\n\n-   Nadia Conti and Elise\n\n-   Nadia Conti and Liam Thorne\n\n-   Sam and Kelly\n\n**Friends:**\n\n-   Sam and Kelly\n\n-   The Intern and The Lookout\n\n**Unfriendly:**\n\n-   Elise and Nadia Conti\n\n**Suspicious:**\n\n-   Boss, Mrs Money, The Intern, The Lookout, The Accountant\n-   Sam, Kelly, Liam Thorne, Elise, Nadia Conti, Davis\n\nFrom the above results, it can be seen that either Sam or Kelly holds the status of The Intern and The Lookout as they are the only ones with the relationship of friends in the conclusion above.\n\nBoss seems to be the one with the most information and power as Mrs Money, The Accountant and The Middlman transmit information to The Boss only\n\n## Q2 Part B\n\nBased on the question 2b, I have categorised them into the 3 different Entity Subgroups: Person, Organisation and Vessel\n\n::: panel-tabset\n### Group by organisation\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(tidytext)\nlibrary(wordcloud)\n\n# 1. Extract communication‐event nodes with their new_index and content\ncomm_nodes <- mc3_nodes_final %>%\n  filter(type == \"Event\", sub_type == \"Communication\") %>%\n  select(event_index = new_index, content)\n\n# 2. Build a mapping from communication events to entities (Organization subtype)\nsend_map <- mc3_edges_final %>%\n  filter(type == \"sent\") %>%\n  transmute(entity_index = from, event_index = to)\n\nrecv_map <- mc3_edges_final %>%\n  filter(type == \"received\") %>%\n  transmute(event_index = from, entity_index = to)\n\nevent_to_entity <- bind_rows(send_map, recv_map)\n\n# 3. Join event_to_entity with comm_nodes, then keep only Organization entities\ncomm_by_entity <- event_to_entity %>%\n  inner_join(comm_nodes, by = \"event_index\") %>%\n  inner_join(\n    mc3_nodes_final %>% \n      select(entity_index = new_index, sub_type, label),\n    by = \"entity_index\"\n  ) %>%\n  filter(sub_type == \"Organization\") %>%\n  select(organization = label, content)\n\n# 4. Collapse all texts per organization\norg_texts <- comm_by_entity %>%\n  group_by(organization) %>%\n  summarize(text = paste(content, collapse = \" \"), .groups = \"drop\")\n\n# 5. Tokenize, remove stop‐words, and compute word frequencies per organization\ntidy_org_words <- org_texts %>%\n  unnest_tokens(word, text) %>%\n  anti_join(stop_words, by = \"word\") %>%\n  count(organization, word, sort = TRUE)\n\n# 6. Plot one word cloud per organization\norg_list <- unique(tidy_org_words$organization)\nn_orgs   <- length(org_list)\nn_cols   <- 3\nn_rows   <- ceiling(n_orgs / n_cols)\n\npar(mfrow = c(n_rows, n_cols), mar = c(0, 0, 0, 0))\nfor (org in org_list) {\n  freq_tbl <- tidy_org_words %>% filter(organization == org)\n  if (nrow(freq_tbl) == 0) {\n    plot.new()\n    title(main = org)\n    next\n  }\n  v <- setNames(freq_tbl$n, freq_tbl$word)\n  wordcloud(\n    words        = names(v),\n    freq         = as.numeric(v),\n    max.words    = 20,\n    scale        = c(3, 0.5),\n    random.order = FALSE\n  )\n  title(main = org, line = -1)\n}\npar(mfrow = c(1, 1))\n```\n:::\n\n\n\nFor Organisation: It can be seen that Team Glitters does not have any pre-dominant topic area.\n\nOceanus City Council, Sailor Shift Team and Green Guardians seems to have common words like nemo, city, reef ,equipment and vessel, showing that they are more concerned about the environment.\n\nV. Miesel Shipping however, is more concerned about regulations as the most commonly used words are permit, operations and documentation.\n\n### Group by Person\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# (Assuming you already have mc3_nodes_final and mc3_edges_final loaded)\n\nlibrary(dplyr)\nlibrary(tidytext)\nlibrary(wordcloud)\n\n# 1. Extract communication‐event nodes with their new_index and content\ncomm_nodes <- mc3_nodes_final %>%\n  filter(type == \"Event\", sub_type == \"Communication\") %>%\n  select(event_index = new_index, content)\n\n# 2. Build a mapping from communication events to entities\nsend_map <- mc3_edges_final %>%\n  filter(type == \"sent\") %>%\n  transmute(entity_index = from, event_index = to)\n\nrecv_map <- mc3_edges_final %>%\n  filter(type == \"received\") %>%\n  transmute(event_index = from, entity_index = to)\n\nevent_to_entity <- bind_rows(send_map, recv_map)\n\n# 3. Join event_to_entity with comm_nodes, then keep only Person entities\ncomm_by_person <- event_to_entity %>%\n  inner_join(comm_nodes, by = \"event_index\") %>%\n  inner_join(\n    mc3_nodes_final %>% \n      select(entity_index = new_index, sub_type, label),\n    by = \"entity_index\"\n  ) %>%\n  filter(sub_type == \"Person\") %>%\n  select(person = label, content)\n\n# 4. Collapse all texts per person\nperson_texts <- comm_by_person %>%\n  group_by(person) %>%\n  summarize(text = paste(content, collapse = \" \"), .groups = \"drop\")\n\n# 5. Tokenize, remove stop‐words, and compute word frequencies per person\ntidy_person_words <- person_texts %>%\n  unnest_tokens(word, text) %>%\n  anti_join(stop_words, by = \"word\") %>%\n  count(person, word, sort = TRUE)\n\n# 6. Plot one word cloud per person\nperson_list <- unique(tidy_person_words$person)\nn_persons   <- length(person_list)\nn_cols      <- 4\nn_rows      <- ceiling(n_persons / n_cols)\n\npar(mfrow = c(n_rows, n_cols), mar = c(0, 0, 0, 0))\nfor (p in person_list) {\n  freq_tbl <- tidy_person_words %>% filter(person == p)\n  if (nrow(freq_tbl) == 0) {\n    plot.new()\n    title(main = p)\n    next\n  }\n  v <- setNames(freq_tbl$n, freq_tbl$word)\n  wordcloud(\n    words        = names(v),\n    freq         = as.numeric(v),\n    max.words    = 10,\n    scale        = c(3, 0.5),\n    random.order = FALSE\n  )\n  title(main = p, line = -1)\n}\npar(mfrow = c(1, 1))\n```\n:::\n\n\n\n**For Person Subgroups:**\n\n**Top 3 Commonly Used Words:**\n\nMrs Money: Meeting, Nemo Reef, Intern\n\nThe Intern: Nemo Reef, Lookout, Money\n\nThe Lookout: Nemo Reef, Intern, tomorrow\n\nBoss: Nemo Reef, meeting, middleman\n\nThe Middleman: Nemo Reef, boss, meeting\n\nThe Accountant: meeting, middleman, boss\n\n**It can be seen that these 6 people are in contact with each other as their most commonly used terms concern each other and usually revolves around Nemo Reef.**\n\nLiam Thorne: Nemo Reef, council, report\n\nNadia Conti: Nemo Reef, documentation, meeting\n\nRodriguez: Nemo reef, davis, remora\n\nSamantha Blake: Nemo Reef, tomorrow, city council\n\nElise: Nemo Reef, tomorrow, meeting\n\n**It can also be seen that these group of people have common schedules like meeting, tomorrow and City Council, and they are also concerned about Nemo Reef.**\n\nClepper Jensen: Miranda, equipment, environmental\n\nMiranda Jordan: Miranda, equipment, clepper Jensen\n\nDavis: Mako, security, equipment\n\nSam: birdwatching, lookout, reef\n\nMako: try, team, remora\n\nKelly: sam, kelly\n\n**These group of people here have different focus and do not have commonailities with the groups above.**\n\n### Group by Vessels\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Extract communication‐event nodes with their new_index and content\ncomm_nodes <- mc3_nodes_final %>%\n  filter(type == \"Event\", sub_type == \"Communication\") %>%\n  select(event_index = new_index, content)\n\n# 2. Build a mapping from communication events to entities (sender/receiver)\nsend_map <- mc3_edges_final %>%\n  filter(type == \"sent\") %>%\n  transmute(entity_index = from, event_index = to)\n\nrecv_map <- mc3_edges_final %>%\n  filter(type == \"received\") %>%\n  transmute(event_index = from, entity_index = to)\n\nevent_to_entity <- bind_rows(send_map, recv_map)\n\n# 3. Join event_to_entity with comm_nodes, then keep only Vessel entities\ncomm_by_vessel <- event_to_entity %>%\n  inner_join(comm_nodes, by = \"event_index\") %>%\n  inner_join(\n    mc3_nodes_final %>%\n      select(entity_index = new_index, sub_type, label),\n    by = \"entity_index\"\n  ) %>%\n  filter(sub_type == \"Vessel\") %>%      # <— change here\n  select(vessel = label, content)\n\n# 4. Collapse all texts per vessel\nvessel_texts <- comm_by_vessel %>%\n  group_by(vessel) %>%\n  summarize(text = paste(content, collapse = \" \"), .groups = \"drop\")\n\n# 5. Tokenize, remove stop‐words, and compute word frequencies per vessel\ntidy_vessel_words <- vessel_texts %>%\n  unnest_tokens(word, text) %>%\n  anti_join(stop_words, by = \"word\") %>%\n  count(vessel, word, sort = TRUE)\n\n# 6. Plot one word cloud per vessel\nvessel_list <- unique(tidy_vessel_words$vessel)\nn_vess   <- length(vessel_list)\nn_cols   <- 4\nn_rows   <- ceiling(n_vess / n_cols)\n\npar(mfrow = c(n_rows, n_cols), mar = c(0, 0, 0, 0))\nfor (ves in vessel_list) {\n  freq_tbl <- tidy_vessel_words %>% filter(vessel == ves)\n  if (nrow(freq_tbl) == 0) {\n    plot.new()\n    title(main = ves)\n    next\n  }\n  v <- setNames(freq_tbl$n, freq_tbl$word)\n  wordcloud(\n    words        = names(v),\n    freq         = as.numeric(v),\n    max.words    = 20,\n    scale        = c(3, 0.5),\n    random.order = FALSE\n  )\n  title(main = ves, line = -1)\n}\npar(mfrow = c(1, 1))\n```\n:::\n\n\n:::\n\n# Question 3\n\n::: panel-tabset\n### Daily Network Graph of Communication\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(patchwork)\n\n\ndaily_comms <- selected_nodes %>%\n  filter(type==\"Event\", sub_type==\"Communication\") %>%\n  mutate(date=as_date(timestamp)) %>%\n  select(idx, date)\n\nall_dates <- sort(unique(daily_comms$date)) %>% discard(is.na)\n\nplots <- map(all_dates, function(d) {\n  comm_idx <- daily_comms %>% filter(date==d) %>% pull(idx)\n  es <- selected_edges %>% filter(type==\"sent\", to %in% comm_idx) %>% transmute(comm=to, sender=from)\n  er <- selected_edges %>% filter(type==\"received\", from %in% comm_idx) %>% transmute(comm=from, receiver=to)\n  dp <- inner_join(es, er, by=\"comm\") %>% transmute(from=sender, to=receiver, type=\"sent\")\n  if (nrow(dp)==0) return(NULL)\n\n  nodes_d <- selected_nodes %>%\n    filter(idx %in% unique(c(dp$from, dp$to)), sub_type %in% c(\"Person\", \"Vessel\"))\n  dp <- dp %>% filter(from %in% nodes_d$idx, to %in% nodes_d$idx)\n  if (nrow(dp)==0) return(NULL)\n\n  nm <- tibble(old=nodes_d$idx, new=seq_len(nrow(nodes_d)))\n  edges2 <- dp %>%\n    left_join(nm, by=c(\"from\"=\"old\")) %>% mutate(from=new) %>% select(-new) %>%\n    left_join(nm, by=c(\"to\"=\"old\")) %>% mutate(to=new) %>% select(-new)\n  nodes2 <- nodes_d %>% mutate(idx2=seq_len(nrow(nodes_d)))\n\n  g <- tbl_graph(nodes=nodes2, edges=edges2, directed=TRUE)\n  lay <- create_layout(g, layout=\"fr\", niter=500, area=vcount(g)^2, repulse=vcount(g)^1.2)\n\n  ggraph(lay) +\n    geom_edge_link(aes(color=type),\n                   arrow=arrow(length=unit(4,\"mm\"), type=\"closed\"),\n                   alpha=0.8, width=1) +\n    geom_node_point(aes(color=sub_type), size=4) +\n    geom_node_text(aes(label=ifelse(sub_type %in% c(\"Person\",\"Vessel\"), label, \"\")),\n                   repel=TRUE, point.padding=unit(0.5,\"lines\"),\n                   box.padding=unit(0.5,\"lines\"), size=6) +\n    scale_edge_color_manual(values=c(sent=\"#7570B3\")) +\n    scale_color_manual(values=c(Person=\"#1b9e77\", Vessel=\"#d95f02\")) +\n    ggtitle(as.character(d)) +\n    theme_void() +\n    theme(plot.title=element_text(size=12,hjust=0.5), legend.position=\"right\")\n})\n\nwrap_plots(plots, ncol=2) +\n  plot_layout(guides=\"collect\") +\n  plot_annotation(title=\"MC3 Communications by Day\")\n```\n:::\n\n\n\n### Communication between People and Vessels\n\n**Additional visualisations are done below to further investigate the communication between the pseudonyms and real names.**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(visNetwork)\n\n# 1. Keep only Person/Vessel nodes, assigning colors by sub_type\nnodes <- selected_nodes %>%\n  filter(sub_type %in% c(\"Person\", \"Vessel\")) %>%\n  transmute(\n    id    = idx,\n    label = label,\n    color = ifelse(sub_type == \"Person\", \"#1b9e77\", \"#d95f02\")\n  )\n\n# 2. Build direct sender→receiver pairs from communication events\nes <- selected_edges %>%\n  filter(type == \"sent\") %>%\n  transmute(comm = to, sender = from)\ner <- selected_edges %>%\n  filter(type == \"received\") %>%\n  transmute(comm = from, receiver = to)\n\n# 3. Join on the communication node to get from→to, then count occurrences\ndp <- inner_join(es, er, by = \"comm\") %>%\n  transmute(from = sender, to = receiver)\n\nedges <- dp %>%\n  count(from, to, name = \"count\") %>%\n  filter(from %in% nodes$id, to %in% nodes$id) %>%\n  mutate(width = count, label = as.character(count))\n\n# 4. Draw a visNetwork: node colors by type, edge width and label by count\nvisNetwork(nodes, edges) %>%\n  visIgraphLayout(layout = \"layout_with_fr\", randomSeed = 123) %>%\n  visEdges(\n    arrows = \"to\",\n    color  = list(color = \"#AAAAAA\", highlight = \"#FF0000\"),\n    font   = list(align = \"middle\")\n  ) %>%\n  visOptions(\n    highlightNearest = TRUE,\n    nodesIdSelection = TRUE\n  )\n```\n:::\n\n\n:::\n\n## Q3 Part A\n\nThe pseudonyms used are:\n\n-   Boss\n\n-   The Intern\n\n-   Mrs Money\n\n-   The Lookout\n\n-   The Accountant\n\n-   The Middleman\n\n## Q3 Part B\n\nMy visualisations help to break down the communication on a daily basis and to draw the connections between the different people based on their communication groups.\n\nFrom the figures above, it can be seen that the Boss is mostly always on the receiving end of the communication, with the exception of Mako(Vessel). The ones who are in direct contact with Boss are Mrs Money, The Middleman, Rodriguez, Davis, Liam Thorne, The Accountant and Mako (Vessel).\n\nMrs Money, however, receives information mainly from The Intern.\n\nThe Lookout and The Intern, however, usually communicates in both directions, with The Intern usually on the receiving end of information.\n\nThe Accountant only communicated with Boss on 11 October and he is often communicating with The Middleman.\n\nThe Lookout also sends informations to Sam.\n\n**There is a clear hierachy when sending information:**\n\nLookout -\\> Intern -\\> Mrs Money/The Accountant/The Middleman -\\> Boss\n\nLookout -\\> Sam\n\n## Q3 Part C\n\nThese visualisations have confirmed my understanding that Boss is likely the leader of the group and the Vessel that is in contact with boss is likely Mako for illegal activities. The illegal activities should be taking place around Nemo Reef or meetings are held around Nemo Reef. The ones of higher positions are probably Mrs Money, The Middleman and The Accountant who reports directly to Boss.\n\nRodriguez, Liam Thorne and Davis seem to be involved directly with The Boss as well.\n\nStrangely, Nadia Conti seems to be at the receiving end of the communciation from Elise, Davis and Rodriguez and only replies to Liam Thorne. Nadia Conti is also in contact with several vessels.\n\nThe Intern and The Lookout seems to be of the same position in the syndicate, but The Intern is the only one who communicates with Mrs Money.\n\nThe Lookout seems to be reporting to Sam as well, as the communication is always in 1 direction.\n\n**From all the previous analysis, I would like to conclude that Rodriguez and Davis are likely involved in the illegal activities as they are in direct contact with Boss. Sam is also likely involved as The Lookout reports to him frequently.**\n\n# References\n\n-   [ISSS608 AY2024-25 April Term](https://isss608-ay2024-25apr.netlify.app/)\n\n-   [visNetwork](https://datastorm-open.github.io/visNetwork/)\n",
    "supporting": [
      "Take-Home_Ex02_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}