{
  "hash": "93a11e2c871268d5a6131bf4aa8726ca",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Exercise 6\"\nauthor: \"Liaw Ying Ting, Celin\"\ndate: 21 May 2025\ndate-modified: \"last-modified\"\n\nformat:\n  html:\n    code-fold: true\n    code-tools: true\n\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n---\n\n\n\n# 10 Visualising and Analysing Time-Oriented Data\n\n## 10.1 Learning Outcome\n\nBy the end of this hands-on exercise, the following data visualisation should be created using R packages:\n\n-   plotting a calendar heatmap by using ggplot2 functions\n\n-   plotting a cycle plot using ggplot2 function\n\n-   plotting a slopegraph\n\n-   plotting a horizon chart\n\n## 10.2 Getting Started\n\nWrite a code chunk to check, install and launch the following R packages: scales, viridis, lubridate, ggtheme, gridExtra, readxl, knitr, data.table and tidyverse\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(scales, viridis, lubridate, ggthemes,\n               gridExtra, readxl, knitr, data.table,\n               CGPfunctions, ggHoriPlot, tidyverse)\n```\n:::\n\n\n\n## 10.3 Plotting Calendar Heatmap\n\nBy the end of of this section, the following will be achieved:\n\n-   plot a calendar heatmap by using ggplot2 functions and extension\n\n-   to write function using R programming\n\n-   to derive specific data and time related field by using base R and lubridate packages\n\n-   to perform data preparation task by using tidyr and dplyr packages\n\n### 10.3.1 The Data\n\nFor the purpose of this hands-on exercise, *eventlog.csv* file will be used. This data file consists of 199,999 rows of time-series cyber attack records by country,\n\n### 10.3.2 Importing the Data\n\nFirst, I will use the coded chunk below to import *eventlog.csv* file into R environment and the data frame will be named as *attacks*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattacks <- read_csv(\"data/eventlog.csv\")\n```\n:::\n\n\n\n### 10.3.3 Examining the data structure\n\nThis function *kable()* can be used to review the structure of the imported data frame.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(head(attacks))\n```\n\n::: {.cell-output-display}\n\n\n|timestamp           |source_country |tz              |\n|:-------------------|:--------------|:---------------|\n|2015-03-12 15:59:16 |CN             |Asia/Shanghai   |\n|2015-03-12 16:00:48 |FR             |Europe/Paris    |\n|2015-03-12 16:02:26 |CN             |Asia/Shanghai   |\n|2015-03-12 16:02:38 |US             |America/Chicago |\n|2015-03-12 16:03:22 |CN             |Asia/Shanghai   |\n|2015-03-12 16:03:45 |CN             |Asia/Shanghai   |\n\n\n:::\n:::\n\n\n\nThere are three columns, namely *timestamp, source_country* and *tz.*\n\n-   *timestamp* field stores data-time values in POSIXct format\n\n-   *source_country* field stores the source of the attack. It is in *ISO 3166-1 alpha-2* country code\n\n-   *tz* field stores time zone of the source IP address\n\n### 10.3.4 Data Preparation\n\nStep 1: Deriving *weekday* and *hour of days* fields\n\nBefore we plot the calendar heatmap, two new fields namely *wkday* and *hour* need to be derived. In this step, we will write a function to perform the task.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_hr_wkday <- function(ts, sc, tz) {\n  real_times <- ymd_hms(ts, \n                        tz = tz[1], \n                        quiet = TRUE)\n  dt <- data.table(source_country = sc,\n                   wkday = weekdays(real_times),\n                   hour = hour(real_times))\n  return(dt)\n  }\n```\n:::\n\n\n\n::: callout-note\n-   `ymd_hms()` and `hour()` are from **{lubridate}** package, and\\\n-   `weekdays()` is a **base** R function.\n:::\n\nStep 2: Deriving the attacks tibble data frame\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwkday_levels <- c('Saturday', 'Friday', \n                  'Thursday', 'Wednesday', \n                  'Tuesday', 'Monday', \n                  'Sunday')\n\nattacks <- attacks %>%\n  group_by(tz) %>%\n  do(make_hr_wkday(.$timestamp, \n                   .$source_country, \n                   .$tz)) %>% \n  ungroup() %>% \n  mutate(wkday = factor(\n    wkday, levels = wkday_levels),\n    hour  = factor(\n      hour, levels = 0:23))\n```\n:::\n\n\n\n::: callout-note\nBesides extracting the necessary data into attacks data frame, mutate() of **dpylr** package is used to convert wkday and hours fields into **factor** so they'll be ordered when plotting\n:::\n\nTable below shows the tidy tibble after processing.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(head(attacks))\n```\n\n::: {.cell-output-display}\n\n\n|tz           |source_country |wkday    |hour |\n|:------------|:--------------|:--------|:----|\n|Africa/Cairo |BG             |Saturday |20   |\n|Africa/Cairo |TW             |Sunday   |6    |\n|Africa/Cairo |TW             |Sunday   |8    |\n|Africa/Cairo |CN             |Sunday   |11   |\n|Africa/Cairo |US             |Sunday   |15   |\n|Africa/Cairo |CA             |Monday   |11   |\n\n\n:::\n:::\n\n\n\n### 10.3.5 Building the Calendar Heatmaps\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrouped <- attacks %>% \n  count(wkday, hour) %>% \n  ungroup() %>%\n  na.omit()\n\nggplot(grouped, \n       aes(hour, \n           wkday, \n           fill = n)) + \ngeom_tile(color = \"white\", \n          size = 0.1) + \ntheme_tufte(base_family = \"Helvetica\") +\ncoord_equal() +\nscale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\nlabs(x = NULL, \n     y = NULL, \n     title = \"Attacks by weekday and time of day\") +\ntheme(axis.ticks = element_blank(),\n      plot.title = element_text(hjust = 0.5),\n      legend.title = element_text(size = 8),\n      legend.text = element_text(size = 6) )\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n::: callout-note\n#### Things to learn from the Code Chunk\n\n-   A tibble data table called *grouped* is derived by aggregating the attack by *wkday* and *hour* fields\n\n-   A new field called *n* is derived by using `group_by()` and `count()` functions\n\n-   `na.omit()` is used to exclude missing value\n\n-   `geom_tile()` is used to plot tiles (grids) at each x and y position\n\n-   `color` and `size` arguments are used to specify the border color and line size of the tiles\n\n-   [theme_tufte()](https://jrnold.github.io/ggthemes/reference/theme_tufte.html) of ggthemes package is used to remove unnecessary chart junk. To learn which visual components fo the default ggplot2 have been excluded, this line can be commented out to examine the default plot\n\n-   `coord_equal()` is used to ensure the plot will have an aspect ratio of 1:1\n\n-   `scale_fill_gradient()` function is used to create a two colour gradient (low-high)\n:::\n\nThe count is then grouped by hour and wkday and plotted. Since there are values for every combination, there is no need to further preprocess the data.\n\n### 10.3.6 Building Multiple Calendar Heatmaps\n\nTo build multiple heatmaps for the top 4 countries with the highest number of attacks.\n\n### 10.3.7 Plotting Multiple Calendar Heatmaps\n\nStep 1: Deriving attack by country object\n\nIn order to identify the top 4 countries with the highest number of attacks, you are required to do the following:\n\n-   count the number of attacjs by country\n\n-   calculate the percent of attacks by country\n\n-   save the results in a tibble data frame\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattacks_by_country <- count(\n  attacks, source_country) %>%\n  mutate(percent = percent(n/sum(n))) %>%\n  arrange(desc(n))\n```\n:::\n\n\n\nStep 2: Preparing the tidy data fram\n\nIn this step, you are required to extract the attack records of the top 4 countries from *attacks* data frame and save the data in a new tibble data frame (i.e. *top4_attacks).*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop4 <- attacks_by_country$source_country[1:4]\ntop4_attacks <- attacks %>%\n  filter(source_country %in% top4) %>%\n  count(source_country, wkday, hour) %>%\n  ungroup() %>%\n  mutate(source_country = factor(\n    source_country, levels = top4)) %>%\n  na.omit()\n```\n:::\n\n\n\n### 10.3.8 Plotting Multiple Calendar Heatmaps\n\nStep 3: Plotting Multiple Calendar Heatmap by using ggplot2 package\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(top4_attacks, \n       aes(hour, \n           wkday, \n           fill = n)) + \n  geom_tile(color = \"white\", \n          size = 0.1) + \n  theme_tufte(base_family = \"Helvetica\") + \n  coord_equal() +\n  scale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\n  facet_wrap(~source_country, ncol = 2) +\n  labs(x = NULL, y = NULL, \n     title = \"Attacks on top 4 countries by weekday and time of day\") +\n  theme(axis.ticks = element_blank(),\n        axis.text.x = element_text(size = 7),\n        plot.title = element_text(hjust = 0.5),\n        legend.title = element_text(size = 8),\n        legend.text = element_text(size = 6) )\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n# 10.4 Plotting Cycle Plot\n\nIn this section, a cycle plot showing the time series patterns and trend of visitor arrivals from Vietnam will be shown using ggplot2 functions\n\n## 10.4.1 Step 1: Data Import\n\nFor the purpose of this hands-on exercise, *arrivals_by_air.xlsx* will be used.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nair <- read_excel(\"data/arrivals_by_air.xlsx\")\n```\n:::\n\n\n\n## 10.4.2 Step 2: Deriving month and year field\n\nTwo new fields called *month* and *year* are derived from *Month-Year* field.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nair$month <- factor(month(air$`Month-Year`), \n                    levels=1:12, \n                    labels=month.abb, \n                    ordered=TRUE) \nair$year <- year(ymd(air$`Month-Year`))\n```\n:::\n\n\n\n## 10.4.3 Step 3: Extracting the target country\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nVietnam <- air %>% \n  select(`Vietnam`, \n         month, \n         year) %>%\n  filter(year >= 2010)\n```\n:::\n\n\n\n## 10.4.4 Step 4: Computing year average arrivals by month\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhline.data <- Vietnam %>% \n  group_by(month) %>%\n  summarise(avgvalue = mean(`Vietnam`))\n```\n:::\n\n\n\n## 10.4.5 Step 5: Plotting the cycle plot\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwindowsFonts(Helvetica = windowsFont(\"Helvetica\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_line(data=Vietnam,\n            aes(x=year, \n                y=`Vietnam`, \n                group=month), \n            colour=\"black\") +\n  geom_hline(aes(yintercept=avgvalue), \n             data=hline.data, \n             linetype=6, \n             colour=\"red\", \n             size=0.5) + \n  facet_grid(~month) +\n  labs(axis.text.x = element_blank(),\n       title = \"Visitor arrivals from Vietnam by air, Jan 2010-Dec 2019\") +\n  xlab(\"\") +\n  ylab(\"No. of Visitors\") +\n  theme_tufte(base_family = \"Helvetica\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\nIn the code above, the x-axis is not visible, so i have made certain changes by reducing the number of breaks in between the x axis and slanting the words to a certain angle.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_line(data = Vietnam,\n            aes(x = year, \n                y = `Vietnam`, \n                group = month), \n            colour = \"black\") +\n  geom_hline(data = hline.data,\n             aes(yintercept = avgvalue), \n             linetype = 6, \n             colour = \"red\", \n             size = 0.5) + \n  facet_grid(~month) +\n  labs(title = \"Visitor arrivals from Vietnam by air, Jan 2010-Dec 2019\") +\n  xlab(\"\") +\n  ylab(\"No. of Visitors\") +\n  scale_x_continuous(breaks = seq(2010, 2020, 4)) +   # Fewer ticks\n  theme_tufte(base_family = \"Helvetica\") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\nAs the grey boxes are not showing even after adding the Helvetica, some panels are added instead.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwindowsFonts(Arial = windowsFont(\"Arial\"))\n\nggplot() + \n  geom_line(data = Vietnam,\n            aes(x = year, \n                y = `Vietnam`, \n                group = month), \n            colour = \"black\") +\n  geom_hline(data = hline.data,\n             aes(yintercept = avgvalue), \n             linetype = 6, \n             colour = \"red\", \n             size = 0.5) + \n  facet_wrap(~month, nrow = 1) +\n  labs(title = \"Visitor arrivals from Vietnam by air, Jan 2010â€“Dec 2019\") +\n  xlab(\"\") +\n  ylab(\"No. of Visitors\") +\n  scale_x_continuous(breaks = seq(2010, 2020, 4)) +\n  theme_tufte(base_family = \"Arial\") +  # Use Arial for Windows compatibility\n  theme(\n    panel.background = element_rect(fill = \"grey95\", colour = \"grey80\"),\n    panel.grid.major = element_line(colour = \"grey80\"),\n    panel.grid.minor = element_line(colour = \"grey90\"),\n    strip.background = element_rect(fill = \"grey85\", colour = \"grey50\"),\n    axis.text.x = element_text(angle = 45, hjust = 1)\n  )\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\n# 10.5 Plotting Slopegraph\n\n## 10.5.1 Step 1: Import data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrice <- read_csv(\"data/rice.csv\")\n```\n:::\n\n\n\n## 10.5.2 Step 2: Plotting the Slopegraph\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrice %>% \n  mutate(Year = factor(Year)) %>%\n  filter(Year %in% c(1961, 1980)) %>%\n  newggslopegraph(Year, Yield, Country,\n                Title = \"Rice Yield of Top 11 Asian Counties\",\n                SubTitle = \"1961-1980\",\n                Caption = \"Prepared by: Celin Liaw\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\n::: callout-note\n#### Things to learn from the code chunk above\n\nFor effective data visualistion design, `factor()` is used to convert the value type of *Year* field from numeric to factor\n:::\n",
    "supporting": [
      "Hands-on_Ex06_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}